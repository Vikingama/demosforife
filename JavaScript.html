<!DOCTYPE html>
<html>
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta http-equiv="X-UA-Compatible" content="ie=edge" />
    <title>JavaScript</title>
  </head>
  <body>
    <span id="span" class="span"></span>
    <noscript id="noScript"> 竟然不支持 JavaScript... </noscript>
  </body>
  <script>
    console.log(noScript);
    console.log(typeof noScript); // HTML 也可以创建全局变量，在创建带有 ID 属性的 HTML 元素时，就会生成对应 ID 的全局变量...
    console.log(span instanceof Object); // true
    var vkz = 0;
    console.log(vkz++); // 0
    console.log((vkz++, vkz)); // 2
    var vlz = 0;
    console.log(++vlz); // 1
    console.log((++vlz, vlz)); // 2
    console.log(0 == '\n'); // true
    console.log(false || false); // false
    console.log(3 && '三'); // 三，表达式结果为 true 返回第一个操作数、结果为 false 返回第二个操作数...
    function zzz() {
      console.log(arguments[0] + '...');
    }
    true && zzz('true');
    false && zzz('false'); // zzz 不会运行...
    console.log('42 == [42]:' + (42 == [42]));
    let za = 'za',
      zb = null,
      zc = undefined,
      zd = NaN;
    console.log('za == Object(za):' + (za == Object(za))); // true，这里的 Object(za) 等价于 new String(za)...
    console.log('zb == Object(za):' + (zb == Object(zb))); // false
    console.log('zc == Object(za):' + (zc == Object(zc))); // false
    console.log('zd == Object(za):' + (zd == Object(zd))); // false
    // 'use strict';
    {
      var i = 0;
      let t = 1;
    }
    console.log(i);
    try {
      console.log(t); // t is not defined...
    } catch (error) {
      console.log(error);
    }
    /*
    script 标签属性：
        异步脚本（一定会在页面的 load 事件前执行）--->async：该立即下载脚本，但不应妨碍页面中的其他操作，比如下载其他资源或等待加载其他脚本；只对外部脚本文件有效。
        charset：通过 src 属性指定的代码的字符集。
        延迟脚本--->defer：脚本可以延迟到文档完全被解析和显示之后再执行；只对外部脚本文件有效。
        type：编写代码使用的脚本语言的内容类型（MIME 类型）。
    */
    // (function () {
    //     alert("<\/script>");
    // })();
    // 文档模式：混杂模式、标准模式、准标准模式
    message = 123; // 相当于 window.message = 123，不同于 var message = 123...
    delete message;
    // typeof 是一个操作符，不是一个函数
    console.log(typeof '123'); // string
    console.log(typeof 123); // number
    console.log(typeof true); // boolean
    console.log(typeof function () {}); //function
    console.log(typeof {}); // object
    console.log(typeof [{}, {}, {}]); // object，数组本质也是一种对象，不过每个 key 为对应的下标
    /*
    undefined 与 null：
        undefined：一个变量最原始的状态，而非人为操作的结果...
            声明了一个变量，但没有赋值
            访问对象上不存在的属性
            函数定义了形参，但没有传递实参
            使用 void 对表达式求值
        null：一个对象被人为的重置为空对象，而非一个变量最原始的状态...
            栈中的变量没有指向堆中的内存对象...
            typeof null --> Object，是因为 JS 数据类型在底层是以二进制的形式表示的，二进制的前三位为 0 会被 typeof 判断为对象类型，而 null 的二进制位恰好都是 0，因此，null 被误判断为 Object...
    undefined 和 null 都表示了一个无效的值...
    NaN：表示一个本来要返回数值的操作数未返回数值的情况...
        任何涉及 NaN 的操作（例如 NaN/10）都会返回 NaN
        NaN 与任何值都不相等，包括 NaN 本身
    */
    console.log(typeof undefined); // undefined
    console.log(typeof null); // object，因为 null 被认为是对空对象的引用，是一个空对象指针
    console.log('null == undefined: ' + (null == undefined)); // undefined 派生于 null
    console.log(isFinite(1)); // 处于最大值和最小值之间 --- true
    console.log(isFinite(Number.MAX_VALUE + Number.MAX_VALUE)); // 超出浏览器所支持的最大（小）值 --- false
    console.log(isNaN(NaN)); // true
    console.log(isNaN(0 / 0)); // true
    console.log(Number(true)); // 1
    console.log(Number(false)); // 0
    console.log(Number(null)); // 0
    console.log(Number(undefined)); // NaN
    console.log(Number(NaN)); // NaN
    console.log(Number('+123')); // 123
    console.log(Number('-123')); // -123
    console.log(Number('')); // 0
    console.log(Number('456dfg123')); // NaN
    console.log(Number([{}])); // NaN
    console.log(Number({})); // NaN
    // parseInt(参数一，参数二（转换进制）);
    // parseFloat();
    var sampleString = 'QQ\u03a3';
    console.log(sampleString.length); // 3, 转义字符长度为 1
    console.log(typeof '123'.toString()); // string
    var sampleNumber = 10;
    console.log(sampleNumber.toString(16)); // 当数字类型调用时，可以传入转换进制
    console.log(NaN.toString()); // NaN
    // console.log(null.toString());报错
    // console.log(undefined.toString());报错
    console.log(typeof String(null));
    console.log(typeof String(undefined));
    console.log('------object------');
    var sampleObject = new Object();
    sampleObject.name = 'VKX';
    console.log(sampleObject.constructor); // 创建当前对象的函数
    console.log(sampleObject.hasOwnProperty('name')); // true, 检查给定的属性在当前对象实例中（而不是在实例的原型中）是否存在
    console.log(sampleObject.isPrototypeOf('name')); // false, 检查传入的对象是否是传入对象的原型
    console.log(sampleObject.propertyIsEnumerable('name')); // 检查给定的属性是否能够使用 for-in 语句来枚举
    console.log(sampleObject.toLocaleString()); // 返回对象的字符串表示，该字符串与执行环境的地区对应
    console.log(sampleObject.toString()); // 返回对象的字符串表示
    console.log(sampleObject.valueOf()); // 返回对象的字符串、数值或布尔值表示
    // 操作符
    var agea = 1,
      ageb = 1;
    agea++;
    ++ageb;
    console.log('agea++: ' + agea);
    console.log('++ageb: ' + ageb);
    agea--;
    --ageb;
    console.log('agea--: ' + agea);
    console.log('--ageb: ' + ageb);
    // 后置递增和递减与前置递增和递减的区别：即递增和递减操作是在包含它们的语句被求值之后才执行的...
    let [m, n, p, q] = [2, 2, 20, 20];
    console.log('let [m, n, p, q] = [2, 2, 20, 20]');
    console.log('--m + p: ' + (--m + p)); // 21
    console.log('m + p: ' + (m + p)); // 21
    console.log('n-- + q: ' + (n-- + q)); // 22
    console.log('n + q: ' + (n + q)); // 21
    console.log((agea += 10));
    console.log((ageb -= 10));
    console.log(Number.POSITIVE_INFINITY * 0); // NaN
    console.log(Number.POSITIVE_INFINITY / Number.NEGATIVE_INFINITY); //NaN
    console.log(Number.POSITIVE_INFINITY % 0); // NaN
    console.log(Number.POSITIVE_INFINITY % Number.NEGATIVE_INFINITY); //NaN
    console.log(Number.POSITIVE_INFINITY + Number.NEGATIVE_INFINITY); //NaN
    console.log(Number.POSITIVE_INFINITY - Number.POSITIVE_INFINITY); //NaN
    console.log('Brick' < 'alphabet'); // true
    console.log('Brick'.toLowerCase() < 'alphabet'.toLowerCase()); // false
    console.log('23' < '3'); // true
    // 任何操作数与 NaN 进行关系比较，结果都是 false
    console.log('s' < 3); // false，"3"不能转换成合理的数值，因此就被转换成了 NaN
    /*
    语句：
        if(){}else{}
        do{}while() ---> 循环体内的代码至少会被执行一次
        while(){} ---> 循环体内的代码有可能永远不会被执行
        for(){}
        for...in...
        label... ---> 在代码中添加标签，以便将来使用（常和 break 与 continue 连用）
        break... ---> 立即退出循环，强制继续执行循环后面的语句 ---> 跳出后不再执行循环
        continue... ---> 立即退出循环，从循环的顶部继续执行 ---> 跳出本次循环，进行下个循环
        with... ---> 是将代码的作用域设置到一个特定的对象中
        switch...case... ---> 在比较值时使用的是全等操作符，不会发生类型转换
    */
    var numz = 0;
    sample: for (var i = 0; i < 10; i++) {
      for (var j = 0; j < 10; j++) {
        if (i == 5 && j == 5) {
          // continue sample; // 95
          break sample; // 55
        }
        numz++;
      }
    }
    console.log(numz);
    // 严格模式下不能用...
    with (location) {
      var originz = origin;
      var pathName = pathname;
    }
    console.log(originz + pathName);
    var num = 25;
    switch (true) {
      case num < 0:
        alert('Less than 0...');
        break;
      case num >= 0 && num <= 10:
        alert('Between 0 and 10...');
        break;
      case num > 10 && num <= 20:
        alert('Between 10 and 20...');
        break;
      default:
        alert('More than 20...');
    }
  </script>
</html>
